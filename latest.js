(() => { /*********************************************************** * Constants ***********************************************************/ const BADGE_ID = "prompttrail-badge"; const BTN_CLASS = "prompttrail-bookmark-btn"; const RAIL_ID = "prompttrail-scroll-rail"; const BLOCK_SELECTOR = "p, li, h1, h2, h3, h4, blockquote, pre"; const STORAGE_KEY = "prompttrail_bookmarks_v2"; // { [convoId]: Bookmark[] } const INDEX_DROPDOWN_ID = "prompttrail-index-dropdown"; /*********************************************************** * Conversation id (ChatGPT URL: /c/<id>) ***********************************************************/ function getConversationId() { const m = location.pathname.match(/\/c\/([a-zA-Z0-9-]+)/); return m ? m[1] : "unknown"; } /*********************************************************** * In-memory bookmarks (mirrors storage) ***********************************************************/ let bookmarks = []; let markerTooltip = null; let tooltipLocked = false; /*********************************************************** * Debug badge (with menu button) ***********************************************************/ function injectBadgeOnce() { if (document.getElementById(BADGE_ID)) return; const badge = document.createElement("div"); badge.id = BADGE_ID; Object.assign(badge.style, { position: "fixed", top: "16px", right: "16px", zIndex: "2147483647", background: "white", border: "1px solid #ddd", borderRadius: "10px", padding: "6px 8px", fontSize: "12px", color: "#111", display: "flex", alignItems: "center", gap: "6px", boxShadow: "0 4px 10px rgba(0,0,0,0.08)", }); badge.innerHTML = <span style="white-space:nowrap;font-weight:600;">PromptTrail</span> <button id="pt-menu-btn" style=" border:none; background:none; cursor:pointer; font-size:16px; line-height:1; padding:2px 4px; " title="Bookmarks" >‚â°</button> ; document.documentElement.appendChild(badge); badge.querySelector("#pt-menu-btn").addEventListener("click", toggleIndexDropdown, true); } injectBadgeOnce(); new MutationObserver(injectBadgeOnce).observe(document.documentElement, { childList: true, subtree: true, }); /*********************************************************** * Index dropdown (single definition) ***********************************************************/ function toggleIndexDropdown(e) { e?.stopPropagation(); // ensure no stale outside handler document.removeEventListener("pointerdown", onOutsideIndexClick, true); const existing = document.getElementById(INDEX_DROPDOWN_ID); if (existing) { existing.remove(); return; } renderIndexDropdown(); } function renderIndexDropdown() { const badge = document.getElementById(BADGE_ID); if (!badge) return; const rect = badge.getBoundingClientRect(); const dropdown = document.createElement("div"); dropdown.id = INDEX_DROPDOWN_ID; Object.assign(dropdown.style, { position: "fixed", top: ${rect.bottom + 6}px, right: ${window.innerWidth - rect.right}px, width: "320px", maxHeight: "420px", background: "#fff", border: "1px solid #ddd", borderRadius: "10px", boxShadow: "0 10px 24px rgba(0,0,0,0.18)", zIndex: "2147483647", overflow: "hidden", fontSize: "13px", color: "#111", }); dropdown.innerHTML = <div style="padding:12px 14px;font-weight:600;border-bottom:1px solid #eee;display:flex;justify-content:space-between;align-items:center;"> <span>üìö Bookmarks</span> <button id="pt-index-close" style="border:none;background:none;cursor:pointer;">‚úñ</button> </div> <div id="pt-index-list" style="flex:1;overflow:auto;padding:8px;max-height:360px;background:#fff;color:#111;"></div> ; document.body.appendChild(dropdown); dropdown.querySelector("#pt-index-close").onclick = () => dropdown.remove(); renderIndexList(); // close on outside click ‚Äî pointerdown is robust and runs earlier than click setTimeout(() => document.addEventListener("pointerdown", onOutsideIndexClick, true), 0); } function onOutsideIndexClick(e) { const dd = document.getElementById(INDEX_DROPDOWN_ID); const badge = document.getElementById(BADGE_ID); if (!dd) return; // use composedPath where available for shadow DOM friendliness const path = e.composedPath ? e.composedPath() : (e.path || []); const clickedInside = dd.contains(e.target) || badge.contains(e.target) || path.includes(dd) || path.includes(badge); if (clickedInside) return; dd.remove(); document.removeEventListener("pointerdown", onOutsideIndexClick, true); } function renderIndexList() { const list = document.getElementById("pt-index-list"); if (!list) return; list.innerHTML = ""; if (!bookmarks.length) { list.innerHTML = <div style="opacity:0.6;padding:8px;">No bookmarks yet</div>; return; } // Sort by vertical position in document const container = findScrollContainer(); const sorted = [...bookmarks].sort((a, b) => { const elA = document.querySelector([data-message-id="${CSS.escape(a.messageId)}"]); const elB = document.querySelector([data-message-id="${CSS.escape(b.messageId)}"]); if (!elA || !elB) return 0; const posA = elementCenterYRelativeToContainer(container, elA); const posB = elementCenterYRelativeToContainer(container, elB); return posA - posB; }); sorted.forEach((b) => { const row = document.createElement("div"); Object.assign(row.style, { padding: "10px", marginBottom: "6px", borderRadius: "8px", background: "#f7f7f7", cursor: "pointer", color: "#111", }); row.innerHTML = <div style="font-weight:600;margin-bottom:6px;color:#111;"> ${escapeHtml(b.desc || b.preview || "Bookmark")} </div> <div style="font-size:12px;opacity:0.7;display:flex;justify-content:space-between;align-items:center;"> <span>${escapeHtml(b.role || "")}</span> <button data-del style="border:none;background:none;cursor:pointer;font-size:14px;">üóëÔ∏è</button> </div> ; row.addEventListener("mouseenter", () => (row.style.background = "#eaeaea")); row.addEventListener("mouseleave", () => (row.style.background = "#f7f7f7")); // Jump on click row.addEventListener("click", (e) => { if (e.target?.dataset?.del) return; const messageEl = document.querySelector([data-message-id="${CSS.escape(b.messageId)}"]); if (!messageEl) return; highlightRangeInMessage(messageEl, b.startAbs, b.endAbs); document.getElementById(INDEX_DROPDOWN_ID)?.remove(); }); // Delete row.querySelector("[data-del]").onclick = (e) => { e.stopPropagation(); deleteBookmark(b); renderIndexList(); }; list.appendChild(row); }); } /*********************************************************** * Scrollbar overlay rail ***********************************************************/ function ensureScrollRail() { if (document.getElementById(RAIL_ID)) return; const rail = document.createElement("div"); rail.id = RAIL_ID; rail.style.position = "fixed"; rail.style.top = "0"; rail.style.right = "2px"; rail.style.height = "100vh"; rail.style.width = "6px"; rail.style.zIndex = "2147483646"; rail.style.pointerEvents = "auto"; rail.style.background = "rgba(0,0,0,0.03)"; document.documentElement.appendChild(rail); } ensureScrollRail(); /*********************************************************** * Helpers (DOM + scroll container) ***********************************************************/ function findMessageContainer(el) { let cur = el; while (cur) { if (cur.nodeType === Node.ELEMENT_NODE && cur.hasAttribute("data-message-id")) { return cur; } cur = cur.parentNode; } return null; } function findScrollContainer() { const messages = document.querySelectorAll("[data-message-id]"); if (messages.length === 0) { return document.scrollingElement || document.documentElement; } let el = messages[0]; while (el) { const style = window.getComputedStyle(el); const overflowY = style.overflowY; if ((overflowY === "auto" || overflowY === "scroll") && el.scrollHeight > el.clientHeight) { return el; } el = el.parentElement; } return document.scrollingElement || document.documentElement; } function elementCenterYRelativeToContainer(container, el) { const elRect = el.getBoundingClientRect(); const containerRect = container.getBoundingClientRect(); const elCenterViewportY = elRect.top + elRect.height / 2; const containerViewportTop = containerRect.top; const distanceInViewport = elCenterViewportY - containerViewportTop; return container.scrollTop + distanceInViewport; } /*********************************************************** * Selection ‚Üí precise offsets within message ***********************************************************/ function getTextOffsetIn(rootEl, node, nodeOffset) { const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, null); let offset = 0; while (walker.nextNode()) { const t = walker.currentNode; if (t === node) return offset + nodeOffset; offset += t.textContent.length; } return -1; } function rangeFromOffsets(rootEl, start, end) { const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, null); let offset = 0; let startNode = null, endNode = null, startOffset = 0, endOffset = 0; while (walker.nextNode()) { const t = walker.currentNode; const len = t.textContent.length; if (!startNode && offset + len >= start) { startNode = t; startOffset = Math.max(0, start - offset); } if (startNode && offset + len >= end) { endNode = t; endOffset = Math.max(0, end - offset); break; } offset += len; } if (!startNode || !endNode) return null; const r = document.createRange(); r.setStart(startNode, startOffset); r.setEnd(endNode, endOffset); return r; } function getSelectionPayload() { const sel = window.getSelection(); if (!sel || sel.isCollapsed || sel.rangeCount === 0) return null; const range = sel.getRangeAt(0); const selectedText = sel.toString().trim(); if (!selectedText) return null; const startEl = range.startContainer.nodeType === Node.TEXT_NODE ? range.startContainer.parentElement : range.startContainer; if (!startEl) return null; const messageEl = findMessageContainer(startEl); if (!messageEl) return null; const startAbs = getTextOffsetIn(messageEl, range.startContainer, range.startOffset); const endAbs = getTextOffsetIn(messageEl, range.endContainer, range.endOffset); if (startAbs < 0 || endAbs < 0 || endAbs <= startAbs) return null; return { messageId: messageEl.getAttribute("data-message-id"), role: messageEl.getAttribute("data-message-author-role"), startAbs, endAbs, selectedText, }; } function defaultDescFromText(text) { const words = (text || "").trim().split(/\s+/).filter(Boolean); return words.slice(0, 10).join(" "); } function escapeHtml(s) { return String(s || "") .replaceAll("&", "&amp;") .replaceAll("<", "&lt;") .replaceAll(">", "&gt;") .replaceAll('"', "&quot;") .replaceAll("'", "&#039;"); } /*********************************************************** * Marker tooltip lifecycle + edit + delete ***********************************************************/ // function hideMarkerTooltip() { // if (markerTooltip) { // markerTooltip.remove(); // markerTooltip = null; // } // } // function hideMarkerTooltip() { // if (tooltipLocked) return; // üö´ do not hide during interaction // if (markerTooltip) { // markerTooltip.remove(); // markerTooltip = null; // } // } function hideMarkerTooltip() { if (markerTooltip) { markerTooltip.remove(); markerTooltip = null; activeTooltipBookmarkId = null; } } let activeTooltipBookmarkId = null; function showMarkerTooltip(marker, bookmark) { // ‚úÖ If tooltip already open for this bookmark, do nothing if (markerTooltip && activeTooltipBookmarkId === bookmark.id) return; // Otherwise replace existing tooltip hideMarkerTooltip(); activeTooltipBookmarkId = bookmark.id; const tooltip = document.createElement("div"); markerTooltip = tooltip; Object.assign(tooltip.style, { position: "fixed", zIndex: "2147483647", maxWidth: "320px", padding: "8px 10px", borderRadius: "10px", background: "rgba(0,0,0,0.88)", color: "#fff", fontSize: "13px", lineHeight: "1.35", boxShadow: "0 6px 24px rgba(0,0,0,0.25)", pointerEvents: "auto", }); tooltip.innerHTML = <div id="pt-desc-view" style="margin-bottom:8px;"> ${escapeHtml(bookmark.desc || bookmark.preview || "Bookmark")} </div> <input id="pt-desc-edit" style=" display:none; width:100%; box-sizing:border-box; padding:6px 8px; font-size:13px; border-radius:6px; border:1px solid #555; outline:none; background:#111; color:#fff; " /> <div style="display:flex; gap:10px; align-items:center;"> <button id="pt-edit" style="background:none;border:none;color:#9fd1ff;cursor:pointer;"> ‚úèÔ∏è Edit </button> <button id="pt-delete" style="background:none;border:none;color:#ffb4b4;cursor:pointer;"> üóëÔ∏è Delete </button> </div> ; document.body.appendChild(tooltip); positionTooltipNearMarker(marker, tooltip); // Block outside handlers tooltip.addEventListener("pointerdown", (e) => e.stopPropagation()); let isEditing = false; const view = tooltip.querySelector("#pt-desc-view"); const input = tooltip.querySelector("#pt-desc-edit"); tooltip.querySelector("#pt-edit").onclick = (e) => { e.stopPropagation(); isEditing = true; input.value = bookmark.desc || bookmark.preview || ""; view.style.display = "none"; input.style.display = "block"; input.focus(); }; function saveEdit() { if (!isEditing) return; isEditing = false; const newDesc = input.value.trim().split(/\s+/).slice(0, 10).join(" "); if (newDesc) { bookmark.desc = newDesc; persistBookmarks(() => { renderBookmarkMarkers(); renderIndexList(); }); } hideMarkerTooltip(); } input.onkeydown = (e) => { if (e.key === "Enter") saveEdit(); if (e.key === "Escape"){ isEditing = false; hideMarkerTooltip(); } }; input.onblur = saveEdit; tooltip.querySelector("#pt-delete").onclick = (e) => { e.stopPropagation(); deleteBookmark(bookmark); hideMarkerTooltip(); }; // Close only when leaving BOTH marker and tooltip let inside = true; const maybeClose = () => { setTimeout(() => { if (!inside) hideMarkerTooltip(); }, 80); }; tooltip.addEventListener("mouseenter", () => {}); // tooltip.addEventListener("mouseleave", () => { // if (isEditing) return; // üö´ do NOT close while editing // hideMarkerTooltip(); // }); const outsideClickHandler = (e) => { if (!markerTooltip) return; const path = e.composedPath ? e.composedPath() : []; const clickedInside = tooltip.contains(e.target) || marker.contains(e.target) || path.includes(tooltip) || path.includes(marker); if (!clickedInside) { hideMarkerTooltip(); document.removeEventListener("pointerdown", outsideClickHandler, true); } }; setTimeout(() => { document.addEventListener("pointerdown", outsideClickHandler, true); }, 0); } function positionTooltipNearMarker(marker, tooltip) { const rect = marker.getBoundingClientRect(); const tooltipHeight = tooltip.offsetHeight || 100; const margin = 10; // Prefer above, otherwise below let top = rect.top - tooltipHeight - margin; if (top < margin) top = rect.bottom + margin; // Clamp top = Math.min(window.innerHeight - tooltipHeight - margin, Math.max(margin, top)); // Stick to right side with small offset tooltip.style.top = ${top}px; tooltip.style.right = 12px; } /*********************************************************** * Storage: load/save (chrome.storage.sync fallback) ***********************************************************/ function loadBookmarks() { const convoId = getConversationId(); if (!chrome?.storage?.sync) { console.warn("[PromptTrail] chrome.storage.sync not available; using memory only."); // keep current (empty) bookmarks renderBookmarkMarkers(); return; } chrome.storage.sync.get(STORAGE_KEY, (data) => { const all = data[STORAGE_KEY] || {}; bookmarks = all[convoId] || []; renderBookmarkMarkers(); renderIndexList(); scheduleRender(); }); } function persistBookmarks(cb) { const convoId = getConversationId(); if (!chrome?.storage?.sync) { cb?.(); renderIndexList(); return; } chrome.storage.sync.get(STORAGE_KEY, (data) => { const all = data[STORAGE_KEY] || {}; all[convoId] = bookmarks; chrome.storage.sync.set({ [STORAGE_KEY]: all }, () => { cb?.(); renderIndexList(); }); }); } loadBookmarks(); /*********************************************************** * Render markers (using saved range midpoint) ***********************************************************/ function renderBookmarkMarkers() { const rail = document.getElementById(RAIL_ID); if (!rail) return; // Clear old markers rail.innerHTML = ""; const container = findScrollContainer(); const scrollRange = Math.max(1, container.scrollHeight - container.clientHeight); bookmarks.forEach((bookmark) => { const messageEl = document.querySelector([data-message-id="${CSS.escape(bookmark.messageId)}"]); if (!messageEl) return; const r = rangeFromOffsets(messageEl, bookmark.startAbs, bookmark.endAbs); let posPercent = 0; if (r) { const rect = r.getBoundingClientRect(); if (rect && rect.height > 0) { // create fake element for center calculation const fake = { getBoundingClientRect: () => rect }; const pos = elementCenterYRelativeToContainer(container, fake); // posPercent = Math.max(0, Math.min(1, pos / scrollRange)); posPercent = Math.max(0, Math.min(0.995, pos / scrollRange)); } else { const pos = elementCenterYRelativeToContainer(container, messageEl); posPercent = Math.max(0, Math.min(1, pos / scrollRange)); } } else { const pos = elementCenterYRelativeToContainer(container, messageEl); posPercent = Math.max(0, Math.min(1, pos / scrollRange)); } appendMarker(rail, posPercent, bookmark); }); } function appendMarker(rail, percent, bookmark) { const marker = document.createElement("div"); marker.style.position = "absolute"; marker.style.top = ${percent * 100}%; marker.style.left = "0"; marker.style.width = "100%"; marker.style.height = "4px"; marker.style.background = "#ff9800"; marker.style.borderRadius = "2px"; marker.style.cursor = "pointer"; marker.style.pointerEvents = "auto"; marker.dataset.ptForId = bookmark.id || ""; marker.dataset.messageId = bookmark.messageId; marker.dataset.startAbs = String(bookmark.startAbs); marker.dataset.endAbs = String(bookmark.endAbs); marker.addEventListener("mouseenter", () => { // show tooltip for this bookmark showMarkerTooltip(marker, bookmark); }); // clicking marker jumps to range marker.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); const messageEl = document.querySelector([data-message-id="${CSS.escape(bookmark.messageId)}"]); if (!messageEl) return; highlightRangeInMessage(messageEl, bookmark.startAbs, bookmark.endAbs); }); rail.appendChild(marker); } /*********************************************************** * Keep markers synced with layout ***********************************************************/ let debounceTimer = null; function scheduleRender() { clearTimeout(debounceTimer); debounceTimer = setTimeout(renderBookmarkMarkers, 120); } window.addEventListener("resize", scheduleRender, { passive: true }); window.addEventListener("orientationchange", scheduleRender, { passive: true }); let lastContainer = null; setInterval(() => { const c = findScrollContainer(); if (c !== lastContainer) { lastContainer = c; c.addEventListener("scroll", scheduleRender, { passive: true }); scheduleRender(); } }, 800); new MutationObserver(scheduleRender).observe(document.body, { childList: true, subtree: true, }); /*********************************************************** * Marker click ‚Üí jump + highlight exact selection ***********************************************************/ function highlightRangeInMessage(messageEl, startAbs, endAbs) { function tryJump(attempt = 0) { const r = rangeFromOffsets(messageEl, startAbs, endAbs); if (!r) return; const rect = r.getBoundingClientRect(); if ((rect.height === 0 || rect.top === 0) && attempt < 3) { setTimeout(() => tryJump(attempt + 1), 80); return; } const container = findScrollContainer(); const containerRect = container.getBoundingClientRect(); const rectCenterViewportY = rect.top + rect.height / 2; const rectCenterInContainer = container.scrollTop + (rectCenterViewportY - containerRect.top); const targetScrollTop = rectCenterInContainer - container.clientHeight / 2; if (container === document.scrollingElement || container === document.documentElement) { window.scrollTo({ top: targetScrollTop, behavior: "auto" }); } else { container.scrollTo({ top: targetScrollTop, behavior: "auto" }); } const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(r); const prev = messageEl.style.outline; messageEl.style.outline = "2px solid #ff9800"; setTimeout(() => { messageEl.style.outline = prev || ""; sel.removeAllRanges(); }, 900); } tryJump(); } /*********************************************************** * Selection-scoped bookmark button (hover only when selection exists) ***********************************************************/ // let activeBlock = null; let selectionPayload = null; let selectionFloater = null; document.addEventListener("selectionchange", () => { const sel = window.getSelection(); if (!sel || sel.isCollapsed || sel.toString().trim() === "") { hideSelectionFloater(); return; } const payload = getSelectionPayload(); if (!payload) { hideSelectionFloater(); return; } showSelectionFloater(payload); }); let selectionTimer; document.addEventListener("selectionchange", debounceCheck); document.addEventListener("mouseup", debounceCheck); function debounceCheck() { clearTimeout(selectionTimer); selectionTimer = setTimeout(() => { const sel = window.getSelection(); if (!sel || sel.isCollapsed || sel.toString().trim() === "") { hideSelectionFloater(); return; } const payload = getSelectionPayload(); if (payload) showSelectionFloater(payload); }, 80); } function showSelectionFloater(payload) { hideSelectionFloater(); const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return; const range = sel.getRangeAt(0); const rect = range.getBoundingClientRect(); if (!rect || rect.width === 0) return; const btn = document.createElement("button"); selectionFloater = btn; const scrollY = window.scrollY; const scrollX = window.scrollX; const top = rect.top + scrollY - 40; const left = rect.right + scrollX - 24; btn.textContent = "üîñ"; btn.title = "Bookmark selection"; Object.assign(btn.style, { position: "fixed", top: ${Math.max(8, top)}px, left: ${Math.max(8, left)}px, zIndex: "2147483647", padding: "6px 8px", borderRadius: "8px", border: "1px solid rgba(0,0,0,0.15)", background: "#fff", cursor: "pointer", fontSize: "14px", boxShadow: "0 4px 12px rgba(0,0,0,0.15)", }); btn.onclick = (e) => { e.stopPropagation(); saveSelectionBookmark(payload); hideSelectionFloater(); window.getSelection().removeAllRanges(); }; document.body.appendChild(btn); } function hideSelectionFloater() { if (selectionFloater) { selectionFloater.remove(); selectionFloater = null; } } function removeButton(blockEl) { const btn = blockEl?.querySelector(.${BTN_CLASS}); if (btn) btn.remove(); } function showButton(blockEl) { if (!blockEl || blockEl.querySelector(.${BTN_CLASS})) return; if (!blockEl.style.position || blockEl.style.position === "static") { blockEl.style.position = "relative"; } const btn = document.createElement("button"); btn.className = BTN_CLASS; btn.textContent = "üîñ Bookmark"; btn.style.position = "absolute"; btn.style.top = "6px"; btn.style.right = "6px"; btn.style.zIndex = "2147483647"; btn.style.fontSize = "12px"; btn.style.padding = "6px 8px"; btn.style.borderRadius = "8px"; btn.style.border = "1px solid rgba(0,0,0,0.12)"; btn.style.background = "rgba(255,255,255,0.95)"; btn.style.cursor = "pointer"; btn.style.pointerEvents = "auto"; btn.style.color = "#111"; blockEl.appendChild(btn); } function getHoveredBlockFromEvent(e) { return e.target && e.target.closest ? e.target.closest(BLOCK_SELECTOR) : null; } /*********************************************************** * Save bookmark: prompt for description (default from selection) ***********************************************************/ function promptDescription(defaultText) { const d = window.prompt("Bookmark description:", defaultText); if (d == null) return null; return d.trim(); } function saveSelectionBookmark(selectionPayload) { const defaultDesc = defaultDescFromText(selectionPayload.selectedText); const desc = window.prompt("Bookmark description:", defaultDesc); if (!desc) return; const bookmark = { id: crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random(), messageId: selectionPayload.messageId, role: selectionPayload.role, startAbs: selectionPayload.startAbs, endAbs: selectionPayload.endAbs, preview: defaultDescFromText(selectionPayload.selectedText), desc: desc.trim().split(/\s+/).slice(0, 10).join(" "), createdAt: Date.now(), }; bookmarks.push(bookmark); persistBookmarks(() => { renderBookmarkMarkers(); scheduleRender(); }); } /*********************************************************** * Utility: default desc & delete helpers ***********************************************************/ function defaultDescFromText(text) { const words = (text || "").trim().split(/\s+/).filter(Boolean); return words.slice(0, 10).join(" "); } function deleteBookmark(bookmark) { bookmarks = bookmarks.filter((b) => bookmark.id ? b.id !== bookmark.id : !(b.messageId === bookmark.messageId && b.startAbs === bookmark.startAbs && b.endAbs === bookmark.endAbs) ); persistBookmarks(() => { renderBookmarkMarkers(); scheduleRender(); renderIndexList(); }); } /*********************************************************** * Helper: highlightRangeInMessage exposed jump function for index ***********************************************************/ function highlightRangeInMessage_forIndex(messageId, startAbs, endAbs) { const messageEl = document.querySelector([data-message-id="${CSS.escape(messageId)}"]); if (!messageEl) return; highlightRangeInMessage(messageEl, startAbs, endAbs); } /*********************************************************** * load initial markers & index ***********************************************************/ // initial render may be empty until storage loads setTimeout(() => { renderBookmarkMarkers(); renderIndexList(); }, 200); document.addEventListener("pointerdown", (e) => { if (!selectionFloater) return; if (selectionFloater.contains(e.target)) return; hideSelectionFloater(); }, true); })();